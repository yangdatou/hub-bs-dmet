#INFO: **** input file is /Users/yangjunjie/work/hub-bs-dmet/fitting.py ****
import os, sys, typing
from typing import List, Tuple, Callable
sys.path.append(".")

from functools import reduce

import numpy, scipy
from scipy import linalg
from scipy.optimize import basinhopping

import jax
import jax.numpy as jnumpy
from jax.scipy.linalg import eigh
from jax.scipy.optimize import minimize

def gen_loss_function_r(h1e: numpy.ndarray, rdm1_tag: numpy.ndarray, fit_inds: numpy.ndarray,
                             nelecs: Tuple[int, int], loss_func_type: int):
    """
    Generate the loss function for the fitting problem.

    The meanfield is assumed to be restricted, meaning that the state is the eigenstate of Sz and S2,
    where the alpha and beta electrons are doubly occupied in the same set of orbitals.

    Args:
        h1e (numpy.ndarray, shape=(nsite, nsite)):
            The one-body Hamiltonian, assumed to be identical for alpha and beta electrons.
        rdm1_tag (numpy.ndarray, shape=(nsite, nsite)):
            The target total density matrix.
        fit_inds (numpy.ndarray, shape=(nfrag, nimp)):
            List of indices for the fitting problem. Each element of the list is a list of indices for a fragment.
            The size of each fragment is assumed to be the same.
        nelecs (Tuple[int, int]):
            The number of alpha and beta electrons.
        loss_func_type (int):
            The type of the loss function.
            - 1: The loss function is the norm of the difference between the impurity block of the target
                 and the fitted density matrix.
            - 2: The loss function is the norm of the difference between the target and the fitted density matrix.

    Returns:
        f (LossFunctionMixin):
            An instance of the LossFunctionMixin class containing:
            - func: The loss function that takes the fitting parameters as input and returns the value of the loss function.
            - grad: The gradient of the loss function.
            - _fill_correlation_potential: A helper function to fill the correlation potential matrix. (for debugging purpose)
            - _get_density_matrix: A helper function to get the density matrix. (for debugging purpose)
    """
    # Convert fit_inds to a JAX array and extract dimensions
    fit_inds = jnumpy.asarray(fit_inds)
    nfrag    = fit_inds.shape[0]
    nimp     = fit_inds.shape[1]
    nsite    = nimp * nfrag

    ind_triu = jnumpy.triu_indices(nimp)
    num_triu = ind_triu[0].shape[0]
    num_parm = num_triu

    # Ensure that dimensions of f1e and rdm1_tag match expected dimensions
    assert h1e.shape      == (nsite, nsite)
    assert rdm1_tag.shape == (nsite, nsite)

    # Build the one-body Hamiltonian for the problem
    f1e = jnumpy.array(h1e)

    def fill_correlation_potential(x):
        # Generate indices for the upper triangle

        # Check that x has expected dimensions
        assert x.shape == (num_triu,)

        # Initialize potential with zeros
        v = jnumpy.zeros((nsite, nsite))

        # Set values in the upper triangle of the correlation potential matrix for each fragment
        for fit_ind in fit_inds:
            ind_fit_0 = fit_ind[ind_triu[0]]
            ind_fit_1 = fit_ind[ind_triu[1]]
            v = v.at[ind_fit_0, ind_fit_1].set(x)

        # Symmetrize the correlation potential matrix
        v_sym = v + jnumpy.transpose(v) - jnumpy.diag(jnumpy.diag(v))
        return v_sym

    def get_density_matrix(f1e):
        # Ensure that the number of alpha and beta electrons are the same
        assert nelecs[0] == nelecs[1]

        # Solve the restricted Hartree-Fock problem to get MO energies and coefficients
        mo_ene_alph, mo_coeff_alph = eigh(f1e)
        mo_ene_beta, mo_coeff_beta = mo_ene_alph, mo_coeff_alph

        # Select indices for occupied orbitals
        occ_idx_alph = jnumpy.argsort(mo_ene_alph)[:nelecs[0]]
        occ_idx_beta = jnumpy.argsort(mo_ene_beta)[:nelecs[1]]

        # Obtain occupied MO coefficients
        coeff_occ_alph = mo_coeff_alph[:, occ_idx_alph]
        coeff_occ_beta = mo_coeff_beta[:, occ_idx_beta]

        # Calculate alpha and beta RDMs
        rdm1_fit_alph  = jnumpy.dot(coeff_occ_alph, coeff_occ_alph.T)
        rdm1_fit_beta  = jnumpy.dot(coeff_occ_beta, coeff_occ_beta.T)

        return rdm1_fit_alph, rdm1_fit_beta

    # Define the loss function based on the specified type
    if loss_func_type == 1:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the norm of the RDM difference
            err = jnumpy.linalg.norm(rdm1_err)
            return err

    elif loss_func_type == 2:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the sum of the norms of the RDM differences for each fragment
            err = sum([jnumpy.linalg.norm(rdm1_err[fit_ind][:, fit_ind]) for fit_ind in fit_inds])
            return err

    elif loss_func_type == 3:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the sum of the norms of the RDM differences for each fragment
            err  = jnumpy.linalg.norm(rdm1_err)
            err += sum([jnumpy.linalg.norm(rdm1_err[fit_ind][:, fit_ind]) for fit_ind in fit_inds])
            return err

    else:
        raise ValueError("Invalid loss function type.")

    # Define a class with the loss function and its gradient, as well as the heler functions
    class _LossFunctionMixin:
        pass

    f = _LossFunctionMixin()

    # Main results
    f.func = (lambda x: numpy.array(func(x)))
    f.grad = (lambda x: numpy.array(jax.grad(func)(x)))
    f.hess = (lambda x: numpy.array(jax.hessian(func)(x)))

    # Helper functions
    f._fill_correlation_potential = fill_correlation_potential
    f._get_density_matrix         = get_density_matrix

    # Other attributes
    f._f1e      = f1e
    f._ind_triu = ind_triu
    f._num_triu = num_triu
    f._num_parm = num_parm

    # Return an instance of the class
    return f

def gen_loss_function_u(h1e: numpy.ndarray, rdm1_tag: numpy.ndarray, fit_inds: numpy.ndarray,
                             nelecs: Tuple[int, int], loss_func_type: int):
    """
    Generate the loss function for the fitting problem.

    The meanfield is assumed to be unrestricted, meaning that the state is the eigenstate of Sz but not S2,
    where the alpha and beta electrons are singly occupied in (possibly) different orbitals.

    Args:
        h1e (numpy.ndarray, shape=(nsite, nsite)):
            The one-body Hamiltonian, assumed to be identical for alpha and beta electrons.
        rdm1_tag (numpy.ndarray, shape=(nsite, nsite)):
            The target total density matrix.
        fit_inds (numpy.ndarray, shape=(nfrag, nimp)):
            List of indices for the fitting problem. Each element of the list is a list of indices for a fragment.
            The size of each fragment is assumed to be the same.
        nelecs (Tuple[int, int]):
            The number of alpha and beta electrons.
        loss_func_type (int):
            The type of the loss function.
            - 1: The loss function is the norm of the difference between the impurity block of the target
                 and the fitted density matrix.
            - 2: The loss function is the norm of the difference between the target and the fitted density matrix.

    Returns:
        f (LossFunctionMixin):
            An instance of the LossFunctionMixin class containing:
            - func: The loss function that takes the fitting parameters as input and returns the value of the loss function.
            - grad: The gradient of the loss function.
            - _fill_correlation_potential: A helper function to fill the correlation potential matrix. (for debugging purpose)
            - _get_density_matrix: A helper function to get the density matrix. (for debugging purpose)
    """
    # Convert fit_inds to a JAX array and extract dimensions
    fit_inds = jnumpy.asarray(fit_inds)
    nfrag    = fit_inds.shape[0]
    nimp     = fit_inds.shape[1]
    nsite    = nimp * nfrag

    ind_triu = jnumpy.triu_indices(nimp)
    num_triu = ind_triu[0].shape[0]
    num_parm = num_triu * 2

    # Ensure that dimensions of f1e and rdm1_tag match expected dimensions
    assert h1e.shape      == (nsite, nsite)
    assert rdm1_tag.shape == (nsite, nsite)

    # Build the one-body Hamiltonian for the problem
    f1e = jnumpy.array((h1e, h1e))

    def fill_correlation_potential(x):
        # Generate indices for the upper triangle

        # Check that x has expected dimensions
        assert x.shape == (num_parm,)

        # Initialize potential with zeros
        va = jnumpy.zeros((nsite, nsite))
        vb = jnumpy.zeros((nsite, nsite))

        # Set values in the upper triangle of the correlation potential matrix for each fragment
        for fit_ind in fit_inds:
            ind_fit_0 = fit_ind[ind_triu[0]]
            ind_fit_1 = fit_ind[ind_triu[1]]

            va = va.at[ind_fit_0, ind_fit_1].set(x[:num_triu])
            vb = vb.at[ind_fit_0, ind_fit_1].set(x[num_triu:])

        # Symmetrize the correlation potential matrix
        va_sym = va + jnumpy.transpose(va) - jnumpy.diag(jnumpy.diag(va))
        vb_sym = vb + jnumpy.transpose(vb) - jnumpy.diag(jnumpy.diag(vb))
        return jnumpy.array((va_sym, vb_sym))

    def get_density_matrix(f1e):
        # Ensure that the number of alpha and beta electrons are the same
        assert nelecs[0] == nelecs[1]

        # Solve the restricted Hartree-Fock problem to get MO energies and coefficients
        mo_ene_alph, mo_coeff_alph = eigh(f1e[0])
        mo_ene_beta, mo_coeff_beta = eigh(f1e[1])

        # Select indices for occupied orbitals
        occ_idx_alph = jnumpy.argsort(mo_ene_alph)[:nelecs[0]]
        occ_idx_beta = jnumpy.argsort(mo_ene_beta)[:nelecs[1]]

        # Obtain occupied MO coefficients
        coeff_occ_alph = mo_coeff_alph[:, occ_idx_alph]
        coeff_occ_beta = mo_coeff_beta[:, occ_idx_beta]

        # Calculate alpha and beta RDMs
        rdm1_fit_alph  = jnumpy.dot(coeff_occ_alph, coeff_occ_alph.T)
        rdm1_fit_beta  = jnumpy.dot(coeff_occ_beta, coeff_occ_beta.T)

        return rdm1_fit_alph, rdm1_fit_beta

    # Define the loss function based on the specified type
    if loss_func_type == 1:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the norm of the RDM difference
            err = jnumpy.linalg.norm(rdm1_err)
            return err

    elif loss_func_type == 2:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the sum of the norms of the RDM differences for each fragment
            err = sum([jnumpy.linalg.norm(rdm1_err[fit_ind][:, fit_ind]) for fit_ind in fit_inds])
            return err

    elif loss_func_type == 3:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the sum of the norms of the RDM differences for each fragment
            err  = jnumpy.linalg.norm(rdm1_err)
            err += sum([jnumpy.linalg.norm(rdm1_err[fit_ind][:, fit_ind]) for fit_ind in fit_inds])
            return err
    else:
        raise ValueError("Invalid loss function type.")

    # Define a class with the loss function and its gradient, as well as the helper functions
    class _LossFunctionMixin:
        pass

    f = _LossFunctionMixin()

    # Main results
    f.func = (lambda x: numpy.array(func(x)))
    f.grad = (lambda x: numpy.array(jax.grad(func)(x)))
    f.hess = (lambda x: numpy.array(jax.hessian(func)(x)))

    # Helper functions
    f._fill_correlation_potential = fill_correlation_potential
    f._get_density_matrix         = get_density_matrix

    # Other attributes
    f._f1e      = f1e
    f._ind_triu = ind_triu
    f._num_triu = num_triu
    f._num_parm = num_parm

    # Return an instance of the class
    return f

def gen_loss_function_g(h1e: numpy.ndarray, rdm1_tag: numpy.ndarray, fit_inds: numpy.ndarray,
                                nelecs: Tuple[int, int], loss_func_type: int):
    """
    Generate the loss function for the fitting problem.

    The meanfield is assumed to be general, meaning that the state is not the eigenstate of Sz or S2,
    where electrons are singly occupied in orbitals without spin labels.

    Args:
        h1e (numpy.ndarray, shape=(nsite, nsite)):
            The one-body Hamiltonian, assumed to be identical for alpha and beta electrons.
        rdm1_tag (numpy.ndarray, shape=(nsite, nsite)):
            The target total density matrix.
        fit_inds (numpy.ndarray, shape=(nfrag, nimp)):
            List of indices for the fitting problem. Each element of the list is a list of indices for a fragment.
            The size of each fragment is assumed to be the same.
        nelecs (Tuple[int, int]):
            The number of alpha and beta electrons. The results may be different from the arguments
            as the generalized Hartree-Fock problem will mix alpha and beta electrons.
        loss_func_type (int):
            The type of the loss function.
            - 1: The loss function is the norm of the difference between the impurity block of the target
                 and the fitted density matrix.
            - 2: The loss function is the norm of the difference between the target and the fitted density matrix.

    Returns:
        f (LossFunctionMixin):
            An instance of the LossFunctionMixin class containing:
            - func: The loss function that takes the fitting parameters as input and returns the value of the loss function.
            - grad: The gradient of the loss function.
            - _fill_correlation_potential: A helper function to fill the correlation potential matrix. (for debugging purpose)
            - _get_density_matrix: A helper function to get the density matrix. (for debugging purpose)
    """

    # Convert fit_inds to a JAX array and extract dimensions
    fit_inds = jnumpy.asarray(fit_inds)
    nfrag    = fit_inds.shape[0]
    nimp     = fit_inds.shape[1]
    nsite    = nimp * nfrag

    ind_triu = jnumpy.triu_indices(nimp)
    num_triu = ind_triu[0].shape[0]
    num_parm = num_triu * 4

    # Ensure that dimensions of f1e and rdm1_tag match expected dimensions
    assert h1e.shape      == (nsite, nsite)
    assert rdm1_tag.shape == (nsite, nsite)

    # Build the one-body Hamiltonian for the problem
    f1e = jnumpy.block([[h1e, jnumpy.zeros((nsite, nsite))], [jnumpy.zeros((nsite, nsite)), h1e]])

    def fill_correlation_potential(x):
        # Check that x has expected dimensions
        assert x.shape == (num_parm,)

        # Initialize potential with zeros
        vaa = jnumpy.zeros((nsite, nsite))
        vba = jnumpy.zeros((nsite, nsite))
        vbb = jnumpy.zeros((nsite, nsite))
        vab = jnumpy.zeros((nsite, nsite))

        # Set values in the upper triangle of the correlation potential matrix for each fragment
        for fit_ind in fit_inds:
            ind_fit_0 = fit_ind[ind_triu[0]]
            ind_fit_1 = fit_ind[ind_triu[1]]

            vaa = vaa.at[ind_fit_0, ind_fit_1].set(x[:num_triu])
            vba = vba.at[ind_fit_0, ind_fit_1].set(x[num_triu:2*num_triu])
            vbb = vbb.at[ind_fit_0, ind_fit_1].set(x[2*num_triu:3*num_triu])
            vab = vab.at[ind_fit_0, ind_fit_1].set(x[3*num_triu:])

        # Symmetrize the correlation potential matrix
        vaa_sym = vaa + jnumpy.transpose(vaa) - jnumpy.diag(jnumpy.diag(vaa))
        vba_sym = vba + jnumpy.transpose(vba) - jnumpy.diag(jnumpy.diag(vba))
        vbb_sym = vbb + jnumpy.transpose(vbb) - jnumpy.diag(jnumpy.diag(vbb))
        vab_sym = vab + jnumpy.transpose(vab) - jnumpy.diag(jnumpy.diag(vab))
        return jnumpy.array(((vaa_sym, vba_sym), (vab_sym, vbb_sym)))

    def get_density_matrix(f1e):
        # Solve the generalized Hartree-Fock problem to get MO energies and coefficients
        mo_ene, mo_coeff = eigh(f1e)

        # Select indices for occupied orbitals
        occ_idx = jnumpy.argsort(mo_ene)[:sum(nelecs)]

        # Obtain occupied MO coefficients
        coeff_occ = mo_coeff[:, occ_idx]

        # Calculate alpha and beta RDMs
        rdm1_fit_g = jnumpy.dot(coeff_occ, coeff_occ.T)
        rdm1_fit_alph = rdm1_fit_g[:nsite, :nsite]
        rdm1_fit_beta = rdm1_fit_g[nsite:, nsite:]

        return rdm1_fit_alph, rdm1_fit_beta

    # Define the loss function based on the specified type
    if loss_func_type == 1:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the norm of the RDM difference
            err = jnumpy.linalg.norm(rdm1_err)
            return err

    elif loss_func_type == 2:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the sum of the norms of the RDM differences for each fragment
            err = sum([jnumpy.linalg.norm(rdm1_err[fit_ind][:, fit_ind]) for fit_ind in fit_inds])
            return err

    elif loss_func_type == 3:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the sum of the norms of the RDM differences for each fragment
            err  = jnumpy.linalg.norm(rdm1_err)
            err += sum([jnumpy.linalg.norm(rdm1_err[fit_ind][:, fit_ind]) for fit_ind in fit_inds])
            return err

    else:
        raise ValueError("Invalid loss function type.")

    # Define a class with the loss function and its gradient, as well as the helper functions
    class _LossFunctionMixin:
        pass

    f = _LossFunctionMixin()

    # Main results
    f.func = (lambda x: numpy.array(func(x)))
    f.grad = (lambda x: numpy.array(jax.grad(func)(x)))
    f.hess = (lambda x: numpy.array(jax.hessian(func)(x)))

    # Helper functions
    f._fill_correlation_potential = fill_correlation_potential
    f._get_density_matrix         = get_density_matrix

    # Other attributes
    f._f1e      = f1e
    f._ind_triu = ind_triu
    f._num_triu = num_triu
    f._num_parm = num_parm

    # Return an instance of the class
    return f

from utils import print_matrix
from utils import RestrictedElectronicStructureProblem

from utils import solve_restricted_hartree_fock
from utils import solve_unrestricted_hartree_fock
from utils import solve_direct_spin1_full_configuration_interaction

from hub import build_hub_model
hub_u = 8.0
nsite  = 6
is_debug = True

for nelecs in [(2, 2), (3, 3), (4, 4)]:
    if is_debug and (not nelecs == (3, 3)):
        continue

    log = open(f"./log/hub-u-{hub_u:6.4f}-nelec-{nelecs[0]+nelecs[1]}" + ".log", "w")

    hub_obj         = build_hub_model(nsite, nelecs, hub_u)
    hub_obj.verbose = 4
    hub_obj.stdout  = log
    dm0_alph, dm0_beta = (lambda xs: (numpy.diag(xs[0]), numpy.diag(xs[1][::-1])))(numpy.asarray([[1, 0] for _ in range(nsite)]).reshape(2, -1))

    res_rhf = solve_restricted_hartree_fock(hub_obj,   dm0=dm0_alph+dm0_beta)
    res_uhf = solve_unrestricted_hartree_fock(hub_obj, dm0=(dm0_alph, dm0_beta))
    res_fci = solve_direct_spin1_full_configuration_interaction(hub_obj)

    ene_rhf = res_rhf.get_ene()
    ene_uhf = res_uhf.get_ene()
    ene_fci = res_fci.get_ene()

    r_rdm1_rhf = res_rhf.get_r_rdm1()
    r_rdm1_uhf = res_uhf.get_r_rdm1()
    r_rdm1_fci = res_fci.get_r_rdm1()
    rdm1_tag   = r_rdm1_fci

    for res in [res_rhf, res_uhf, res_fci]:
        ene    = res.get_ene()
        r_rdm1 = res.get_r_rdm1()
        u_rdm1 = res.get_u_rdm1()

        dm_err = numpy.abs(r_rdm1_fci - r_rdm1) 
        err_max = numpy.max(dm_err)
        err_avg = numpy.linalg.norm(dm_err) / numpy.size(dm_err)

        print(f"\n\n{res.__class__.__name__}", file=log)
        print(f"Energy: {ene:6.4f}, Error Max: {err_max:6.4e}, Avg: {err_avg:6.4e}", file=log)
        print_matrix(r_rdm1,    t="r_rdm1 = ", stdout=log)
        print_matrix(u_rdm1[0], t="u_rdm1_alph = ", stdout=log)
        print_matrix(u_rdm1[1], t="u_rdm1_beta = ", stdout=log)

    for igen_loss, gen_loss in enumerate([gen_loss_function_r, gen_loss_function_u, gen_loss_function_g]):
        for (nimp, loss_func_type) in [(2, 1), (2, 2), (2, 3), (nsite, 1)]:
            if is_debug and (not (nimp == 2 and loss_func_type == 2)):
                continue
            
            f = gen_loss(
                hub_obj.h1, rdm1_tag, nelecs=nelecs, loss_func_type=loss_func_type, 
                fit_inds=numpy.asarray([[i+ifrag*nimp for i in range(nimp)] for ifrag in range(nsite // nimp)])
                )

            print("\n\n" + "#"*20, file=log)
            print(f"{gen_loss.__name__}", file=log)
            print(f"nimp = {nimp}, nsite = {nsite}", file=log)
            print(f"nelecs = {nelecs}", file=log)
            print(f"loss_func_type = {loss_func_type}", file=log)

            global count
            count = 0

            def callback(x, y, accepted):
                f1e_fit  = f._f1e + f._fill_correlation_potential(x)
                rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(f._get_density_matrix(f1e_fit))
                rdm1_err = jnumpy.abs(rdm1_tag - rdm1_fit)
                err_mean = jnumpy.linalg.norm(rdm1_err) / numpy.size(rdm1_err)
                err_max  = jnumpy.max(rdm1_err)

                global count
                if is_debug:
                    print(f"\nLoss Function = {y:6.4e}, {f.func(x):6.4e}, Error Mean: {err_mean:6.4e}, Max: {err_max:6.4e}, Count: {count}")
                    print(f"x = " + " ".join([f"{xi:6.4f}" for xi in x]))
                #     print_matrix(f1e_fit[0], t="f1e_fit  = ")
                #     print_matrix(f1e_fit[1], t="f1e_fit  = ")
                #     print_matrix(rdm1_fit,   t="rdm1_fit = ")
                #     print_matrix(rdm1_err,   t="rdm1_err = ")
                #     assert count != 10
                
                print(f"Loss Function = {y:6.4e}, Error Mean: {err_mean:6.4e}, Max: {err_max:6.4e}, Count: {count}", file=log)
                count += 1

            kwargs = {
                "method": "bfgs", 
                "jac": f.grad, 
                "tol": 1e-4, 
                "options": {"disp": False, "maxiter": 1000}
                }

            x0 = numpy.zeros(f._num_parm)

            res = basinhopping(
                f.func, x0, niter=1000, T=0.1, stepsize=0.6, disp=False,
                callback=callback, minimizer_kwargs=kwargs, 
                niter_success=100, interval=10, 
                )

            x = res.x
            f1e_fit  = f._f1e + f._fill_correlation_potential(x)
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(f._get_density_matrix(f1e_fit))
            rdm1_err = jnumpy.abs(rdm1_tag - rdm1_fit)
            err_mean = jnumpy.linalg.norm(rdm1_err) / numpy.size(rdm1_err)
            err_max  = jnumpy.max(rdm1_err)

            print(f"\nLoss Function = {y:6.4e}, Error Mean: {err_mean:6.4e}, Max: {err_max:6.4e}, Count: {count}", file=log)
            print(f"Success = {res.lowest_optimization_result.success}", file=log)
            print(f"Message = {res.lowest_optimization_result.message}", file=log)
            print(f"x = " + " ".join([f"{xi:6.4f}" for xi in x]), file=log)
            
            print(res, file=log)

            print_matrix(rdm1_fit,   t="rdm1_fit = ", stdout=log)
            print_matrix(rdm1_tag,   t="rdm1_tag = ", stdout=log)
            print("\n\n" + "#"*20, file=log)#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Junjies-MacBook-Air.local', release='22.5.0', version='Darwin Kernel Version 22.5.0: Thu Jun  8 22:21:34 PDT 2023; root:xnu-8796.121.3~7/RELEASE_ARM64_T8112', machine='arm64')  Threads 1
Python 3.11.3 | packaged by conda-forge | (main, Apr  6 2023, 08:58:31) [Clang 14.0.6 ]
numpy 1.24.3  scipy 1.10.1
Date: Thu Jul 20 22:44:47 2023
PySCF version 2.2.1
PySCF path  /Users/yangjunjie/packages/pyscf/pyscf-2.2.1/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 0
[INPUT] num. electrons = 6
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom

nuclear repulsion = 0
number of shells = 0
number of NR pGTOs = 0
number of NR cGTOs = 0
basis = sto-3g
ecp = {}
CPU time:         0.47


******** <class 'pyscf.scf.hf.RHF'> ********
method = RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-06
SCF conv_tol_grad = None
SCF max_cycles = 200
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/14/127wb84x5yx1jh4dxrvgcfkm0000gn/T/tmpfzow1ov7
max_memory 4000 MB (current use 0 MB)
Overwritten attributes  get_hcore get_ovlp  of <class 'pyscf.scf.hf.RHF'>
Set gradient conv threshold to 0.001
init E= 12
  HOMO = 3  LUMO = 5
cycle= 1 E= 3.99999999999999  delta_E=   -8  |g|= 7.41e-15  |ddm|= 2.45
  HOMO = 3  LUMO = 5
cycle= 2 E= 4.00000000000001  delta_E= 2.13e-14  |g|= 1.29e-14  |ddm|= 5.62e-15
  HOMO = 3  LUMO = 5
Extra cycle  E= 4  delta_E= -1.42e-14  |g|= 4.32e-14  |ddm|= 8.98e-15
converged SCF energy = 4
#INFO: **** input file is /Users/yangjunjie/work/hub-bs-dmet/fitting.py ****
import os, sys, typing
from typing import List, Tuple, Callable
sys.path.append(".")

from functools import reduce

import numpy, scipy
from scipy import linalg
from scipy.optimize import basinhopping

import jax
import jax.numpy as jnumpy
from jax.scipy.linalg import eigh
from jax.scipy.optimize import minimize

def gen_loss_function_r(h1e: numpy.ndarray, rdm1_tag: numpy.ndarray, fit_inds: numpy.ndarray,
                             nelecs: Tuple[int, int], loss_func_type: int):
    """
    Generate the loss function for the fitting problem.

    The meanfield is assumed to be restricted, meaning that the state is the eigenstate of Sz and S2,
    where the alpha and beta electrons are doubly occupied in the same set of orbitals.

    Args:
        h1e (numpy.ndarray, shape=(nsite, nsite)):
            The one-body Hamiltonian, assumed to be identical for alpha and beta electrons.
        rdm1_tag (numpy.ndarray, shape=(nsite, nsite)):
            The target total density matrix.
        fit_inds (numpy.ndarray, shape=(nfrag, nimp)):
            List of indices for the fitting problem. Each element of the list is a list of indices for a fragment.
            The size of each fragment is assumed to be the same.
        nelecs (Tuple[int, int]):
            The number of alpha and beta electrons.
        loss_func_type (int):
            The type of the loss function.
            - 1: The loss function is the norm of the difference between the impurity block of the target
                 and the fitted density matrix.
            - 2: The loss function is the norm of the difference between the target and the fitted density matrix.

    Returns:
        f (LossFunctionMixin):
            An instance of the LossFunctionMixin class containing:
            - func: The loss function that takes the fitting parameters as input and returns the value of the loss function.
            - grad: The gradient of the loss function.
            - _fill_correlation_potential: A helper function to fill the correlation potential matrix. (for debugging purpose)
            - _get_density_matrix: A helper function to get the density matrix. (for debugging purpose)
    """
    # Convert fit_inds to a JAX array and extract dimensions
    fit_inds = jnumpy.asarray(fit_inds)
    nfrag    = fit_inds.shape[0]
    nimp     = fit_inds.shape[1]
    nsite    = nimp * nfrag

    ind_triu = jnumpy.triu_indices(nimp)
    num_triu = ind_triu[0].shape[0]
    num_parm = num_triu

    # Ensure that dimensions of f1e and rdm1_tag match expected dimensions
    assert h1e.shape      == (nsite, nsite)
    assert rdm1_tag.shape == (nsite, nsite)

    # Build the one-body Hamiltonian for the problem
    f1e = jnumpy.array(h1e)

    def fill_correlation_potential(x):
        # Generate indices for the upper triangle

        # Check that x has expected dimensions
        assert x.shape == (num_triu,)

        # Initialize potential with zeros
        v = jnumpy.zeros((nsite, nsite))

        # Set values in the upper triangle of the correlation potential matrix for each fragment
        for fit_ind in fit_inds:
            ind_fit_0 = fit_ind[ind_triu[0]]
            ind_fit_1 = fit_ind[ind_triu[1]]
            v = v.at[ind_fit_0, ind_fit_1].set(x)

        # Symmetrize the correlation potential matrix
        v_sym = v + jnumpy.transpose(v) - jnumpy.diag(jnumpy.diag(v))
        return v_sym

    def get_density_matrix(f1e):
        # Ensure that the number of alpha and beta electrons are the same
        assert nelecs[0] == nelecs[1]

        # Solve the restricted Hartree-Fock problem to get MO energies and coefficients
        mo_ene_alph, mo_coeff_alph = eigh(f1e)
        mo_ene_beta, mo_coeff_beta = mo_ene_alph, mo_coeff_alph

        # Select indices for occupied orbitals
        occ_idx_alph = jnumpy.argsort(mo_ene_alph)[:nelecs[0]]
        occ_idx_beta = jnumpy.argsort(mo_ene_beta)[:nelecs[1]]

        # Obtain occupied MO coefficients
        coeff_occ_alph = mo_coeff_alph[:, occ_idx_alph]
        coeff_occ_beta = mo_coeff_beta[:, occ_idx_beta]

        # Calculate alpha and beta RDMs
        rdm1_fit_alph  = jnumpy.dot(coeff_occ_alph, coeff_occ_alph.T)
        rdm1_fit_beta  = jnumpy.dot(coeff_occ_beta, coeff_occ_beta.T)

        return rdm1_fit_alph, rdm1_fit_beta

    # Define the loss function based on the specified type
    if loss_func_type == 1:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the norm of the RDM difference
            err = jnumpy.linalg.norm(rdm1_err)
            return err

    elif loss_func_type == 2:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the sum of the norms of the RDM differences for each fragment
            err = sum([jnumpy.linalg.norm(rdm1_err[fit_ind][:, fit_ind]) for fit_ind in fit_inds])
            return err

    elif loss_func_type == 3:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the sum of the norms of the RDM differences for each fragment
            err  = jnumpy.linalg.norm(rdm1_err)
            err += sum([jnumpy.linalg.norm(rdm1_err[fit_ind][:, fit_ind]) for fit_ind in fit_inds])
            return err

    else:
        raise ValueError("Invalid loss function type.")

    # Define a class with the loss function and its gradient, as well as the heler functions
    class _LossFunctionMixin:
        pass

    f = _LossFunctionMixin()

    # Main results
    f.func = (lambda x: numpy.array(func(x)))
    f.grad = (lambda x: numpy.array(jax.grad(func)(x)))
    f.hess = (lambda x: numpy.array(jax.hessian(func)(x)))

    # Helper functions
    f._fill_correlation_potential = fill_correlation_potential
    f._get_density_matrix         = get_density_matrix

    # Other attributes
    f._f1e      = f1e
    f._ind_triu = ind_triu
    f._num_triu = num_triu
    f._num_parm = num_parm

    # Return an instance of the class
    return f

def gen_loss_function_u(h1e: numpy.ndarray, rdm1_tag: numpy.ndarray, fit_inds: numpy.ndarray,
                             nelecs: Tuple[int, int], loss_func_type: int):
    """
    Generate the loss function for the fitting problem.

    The meanfield is assumed to be unrestricted, meaning that the state is the eigenstate of Sz but not S2,
    where the alpha and beta electrons are singly occupied in (possibly) different orbitals.

    Args:
        h1e (numpy.ndarray, shape=(nsite, nsite)):
            The one-body Hamiltonian, assumed to be identical for alpha and beta electrons.
        rdm1_tag (numpy.ndarray, shape=(nsite, nsite)):
            The target total density matrix.
        fit_inds (numpy.ndarray, shape=(nfrag, nimp)):
            List of indices for the fitting problem. Each element of the list is a list of indices for a fragment.
            The size of each fragment is assumed to be the same.
        nelecs (Tuple[int, int]):
            The number of alpha and beta electrons.
        loss_func_type (int):
            The type of the loss function.
            - 1: The loss function is the norm of the difference between the impurity block of the target
                 and the fitted density matrix.
            - 2: The loss function is the norm of the difference between the target and the fitted density matrix.

    Returns:
        f (LossFunctionMixin):
            An instance of the LossFunctionMixin class containing:
            - func: The loss function that takes the fitting parameters as input and returns the value of the loss function.
            - grad: The gradient of the loss function.
            - _fill_correlation_potential: A helper function to fill the correlation potential matrix. (for debugging purpose)
            - _get_density_matrix: A helper function to get the density matrix. (for debugging purpose)
    """
    # Convert fit_inds to a JAX array and extract dimensions
    fit_inds = jnumpy.asarray(fit_inds)
    nfrag    = fit_inds.shape[0]
    nimp     = fit_inds.shape[1]
    nsite    = nimp * nfrag

    ind_triu = jnumpy.triu_indices(nimp)
    num_triu = ind_triu[0].shape[0]
    num_parm = num_triu * 2

    # Ensure that dimensions of f1e and rdm1_tag match expected dimensions
    assert h1e.shape      == (nsite, nsite)
    assert rdm1_tag.shape == (nsite, nsite)

    # Build the one-body Hamiltonian for the problem
    f1e = jnumpy.array((h1e, h1e))

    def fill_correlation_potential(x):
        # Generate indices for the upper triangle

        # Check that x has expected dimensions
        assert x.shape == (num_parm,)

        # Initialize potential with zeros
        va = jnumpy.zeros((nsite, nsite))
        vb = jnumpy.zeros((nsite, nsite))

        # Set values in the upper triangle of the correlation potential matrix for each fragment
        for fit_ind in fit_inds:
            ind_fit_0 = fit_ind[ind_triu[0]]
            ind_fit_1 = fit_ind[ind_triu[1]]

            va = va.at[ind_fit_0, ind_fit_1].set(x[:num_triu])
            vb = vb.at[ind_fit_0, ind_fit_1].set(x[num_triu:])

        # Symmetrize the correlation potential matrix
        va_sym = va + jnumpy.transpose(va) - jnumpy.diag(jnumpy.diag(va))
        vb_sym = vb + jnumpy.transpose(vb) - jnumpy.diag(jnumpy.diag(vb))
        return jnumpy.array((va_sym, vb_sym))

    def get_density_matrix(f1e):
        # Ensure that the number of alpha and beta electrons are the same
        assert nelecs[0] == nelecs[1]

        # Solve the restricted Hartree-Fock problem to get MO energies and coefficients
        mo_ene_alph, mo_coeff_alph = eigh(f1e[0])
        mo_ene_beta, mo_coeff_beta = eigh(f1e[1])

        # Select indices for occupied orbitals
        occ_idx_alph = jnumpy.argsort(mo_ene_alph)[:nelecs[0]]
        occ_idx_beta = jnumpy.argsort(mo_ene_beta)[:nelecs[1]]

        # Obtain occupied MO coefficients
        coeff_occ_alph = mo_coeff_alph[:, occ_idx_alph]
        coeff_occ_beta = mo_coeff_beta[:, occ_idx_beta]

        # Calculate alpha and beta RDMs
        rdm1_fit_alph  = jnumpy.dot(coeff_occ_alph, coeff_occ_alph.T)
        rdm1_fit_beta  = jnumpy.dot(coeff_occ_beta, coeff_occ_beta.T)

        return rdm1_fit_alph, rdm1_fit_beta

    # Define the loss function based on the specified type
    if loss_func_type == 1:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the norm of the RDM difference
            err = jnumpy.linalg.norm(rdm1_err)
            return err

    elif loss_func_type == 2:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the sum of the norms of the RDM differences for each fragment
            err = sum([jnumpy.linalg.norm(rdm1_err[fit_ind][:, fit_ind]) for fit_ind in fit_inds])
            return err

    elif loss_func_type == 3:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the sum of the norms of the RDM differences for each fragment
            err  = jnumpy.linalg.norm(rdm1_err)
            err += sum([jnumpy.linalg.norm(rdm1_err[fit_ind][:, fit_ind]) for fit_ind in fit_inds])
            return err
    else:
        raise ValueError("Invalid loss function type.")

    # Define a class with the loss function and its gradient, as well as the helper functions
    class _LossFunctionMixin:
        pass

    f = _LossFunctionMixin()

    # Main results
    f.func = (lambda x: numpy.array(func(x)))
    f.grad = (lambda x: numpy.array(jax.grad(func)(x)))
    f.hess = (lambda x: numpy.array(jax.hessian(func)(x)))

    # Helper functions
    f._fill_correlation_potential = fill_correlation_potential
    f._get_density_matrix         = get_density_matrix

    # Other attributes
    f._f1e      = f1e
    f._ind_triu = ind_triu
    f._num_triu = num_triu
    f._num_parm = num_parm

    # Return an instance of the class
    return f

def gen_loss_function_g(h1e: numpy.ndarray, rdm1_tag: numpy.ndarray, fit_inds: numpy.ndarray,
                                nelecs: Tuple[int, int], loss_func_type: int):
    """
    Generate the loss function for the fitting problem.

    The meanfield is assumed to be general, meaning that the state is not the eigenstate of Sz or S2,
    where electrons are singly occupied in orbitals without spin labels.

    Args:
        h1e (numpy.ndarray, shape=(nsite, nsite)):
            The one-body Hamiltonian, assumed to be identical for alpha and beta electrons.
        rdm1_tag (numpy.ndarray, shape=(nsite, nsite)):
            The target total density matrix.
        fit_inds (numpy.ndarray, shape=(nfrag, nimp)):
            List of indices for the fitting problem. Each element of the list is a list of indices for a fragment.
            The size of each fragment is assumed to be the same.
        nelecs (Tuple[int, int]):
            The number of alpha and beta electrons. The results may be different from the arguments
            as the generalized Hartree-Fock problem will mix alpha and beta electrons.
        loss_func_type (int):
            The type of the loss function.
            - 1: The loss function is the norm of the difference between the impurity block of the target
                 and the fitted density matrix.
            - 2: The loss function is the norm of the difference between the target and the fitted density matrix.

    Returns:
        f (LossFunctionMixin):
            An instance of the LossFunctionMixin class containing:
            - func: The loss function that takes the fitting parameters as input and returns the value of the loss function.
            - grad: The gradient of the loss function.
            - _fill_correlation_potential: A helper function to fill the correlation potential matrix. (for debugging purpose)
            - _get_density_matrix: A helper function to get the density matrix. (for debugging purpose)
    """

    # Convert fit_inds to a JAX array and extract dimensions
    fit_inds = jnumpy.asarray(fit_inds)
    nfrag    = fit_inds.shape[0]
    nimp     = fit_inds.shape[1]
    nsite    = nimp * nfrag

    ind_triu = jnumpy.triu_indices(nimp)
    num_triu = ind_triu[0].shape[0]
    num_parm = num_triu * 4

    # Ensure that dimensions of f1e and rdm1_tag match expected dimensions
    assert h1e.shape      == (nsite, nsite)
    assert rdm1_tag.shape == (nsite, nsite)

    # Build the one-body Hamiltonian for the problem
    f1e = jnumpy.block([[h1e, jnumpy.zeros((nsite, nsite))], [jnumpy.zeros((nsite, nsite)), h1e]])

    def fill_correlation_potential(x):
        # Check that x has expected dimensions
        assert x.shape == (num_parm,)

        # Initialize potential with zeros
        vaa = jnumpy.zeros((nsite, nsite))
        vba = jnumpy.zeros((nsite, nsite))
        vbb = jnumpy.zeros((nsite, nsite))
        vab = jnumpy.zeros((nsite, nsite))

        # Set values in the upper triangle of the correlation potential matrix for each fragment
        for fit_ind in fit_inds:
            ind_fit_0 = fit_ind[ind_triu[0]]
            ind_fit_1 = fit_ind[ind_triu[1]]

            vaa = vaa.at[ind_fit_0, ind_fit_1].set(x[:num_triu])
            vba = vba.at[ind_fit_0, ind_fit_1].set(x[num_triu:2*num_triu])
            vbb = vbb.at[ind_fit_0, ind_fit_1].set(x[2*num_triu:3*num_triu])
            vab = vab.at[ind_fit_0, ind_fit_1].set(x[3*num_triu:])

        # Symmetrize the correlation potential matrix
        vaa_sym = vaa + jnumpy.transpose(vaa) - jnumpy.diag(jnumpy.diag(vaa))
        vba_sym = vba + jnumpy.transpose(vba) - jnumpy.diag(jnumpy.diag(vba))
        vbb_sym = vbb + jnumpy.transpose(vbb) - jnumpy.diag(jnumpy.diag(vbb))
        vab_sym = vab + jnumpy.transpose(vab) - jnumpy.diag(jnumpy.diag(vab))
        return jnumpy.array(((vaa_sym, vba_sym), (vab_sym, vbb_sym)))

    def get_density_matrix(f1e):
        # Solve the generalized Hartree-Fock problem to get MO energies and coefficients
        mo_ene, mo_coeff = eigh(f1e)

        # Select indices for occupied orbitals
        occ_idx = jnumpy.argsort(mo_ene)[:sum(nelecs)]

        # Obtain occupied MO coefficients
        coeff_occ = mo_coeff[:, occ_idx]

        # Calculate alpha and beta RDMs
        rdm1_fit_g = jnumpy.dot(coeff_occ, coeff_occ.T)
        rdm1_fit_alph = rdm1_fit_g[:nsite, :nsite]
        rdm1_fit_beta = rdm1_fit_g[nsite:, nsite:]

        return rdm1_fit_alph, rdm1_fit_beta

    # Define the loss function based on the specified type
    if loss_func_type == 1:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the norm of the RDM difference
            err = jnumpy.linalg.norm(rdm1_err)
            return err

    elif loss_func_type == 2:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the sum of the norms of the RDM differences for each fragment
            err = sum([jnumpy.linalg.norm(rdm1_err[fit_ind][:, fit_ind]) for fit_ind in fit_inds])
            return err

    elif loss_func_type == 3:
        def func(x):
            # Fill the correlation potential and calculate f1e
            f1e_fit  = f1e + fill_correlation_potential(x)
            # Obtain the total RDM
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(get_density_matrix(f1e_fit))
            # Calculate the difference between the target and fitted RDMs
            rdm1_err = rdm1_tag - rdm1_fit
            # The loss function is the sum of the norms of the RDM differences for each fragment
            err  = jnumpy.linalg.norm(rdm1_err)
            err += sum([jnumpy.linalg.norm(rdm1_err[fit_ind][:, fit_ind]) for fit_ind in fit_inds])
            return err

    else:
        raise ValueError("Invalid loss function type.")

    # Define a class with the loss function and its gradient, as well as the helper functions
    class _LossFunctionMixin:
        pass

    f = _LossFunctionMixin()

    # Main results
    f.func = (lambda x: numpy.array(func(x)))
    f.grad = (lambda x: numpy.array(jax.grad(func)(x)))
    f.hess = (lambda x: numpy.array(jax.hessian(func)(x)))

    # Helper functions
    f._fill_correlation_potential = fill_correlation_potential
    f._get_density_matrix         = get_density_matrix

    # Other attributes
    f._f1e      = f1e
    f._ind_triu = ind_triu
    f._num_triu = num_triu
    f._num_parm = num_parm

    # Return an instance of the class
    return f

from utils import print_matrix
from utils import RestrictedElectronicStructureProblem

from utils import solve_restricted_hartree_fock
from utils import solve_unrestricted_hartree_fock
from utils import solve_direct_spin1_full_configuration_interaction

from hub import build_hub_model
hub_u = 8.0
nsite  = 6
is_debug = True

for nelecs in [(2, 2), (3, 3), (4, 4)]:
    if is_debug and (not nelecs == (3, 3)):
        continue

    log = open(f"./log/hub-u-{hub_u:6.4f}-nelec-{nelecs[0]+nelecs[1]}" + ".log", "w")

    hub_obj         = build_hub_model(nsite, nelecs, hub_u)
    hub_obj.verbose = 4
    hub_obj.stdout  = log
    dm0_alph, dm0_beta = (lambda xs: (numpy.diag(xs[0]), numpy.diag(xs[1][::-1])))(numpy.asarray([[1, 0] for _ in range(nsite)]).reshape(2, -1))

    res_rhf = solve_restricted_hartree_fock(hub_obj,   dm0=dm0_alph+dm0_beta)
    res_uhf = solve_unrestricted_hartree_fock(hub_obj, dm0=(dm0_alph, dm0_beta))
    res_fci = solve_direct_spin1_full_configuration_interaction(hub_obj)

    ene_rhf = res_rhf.get_ene()
    ene_uhf = res_uhf.get_ene()
    ene_fci = res_fci.get_ene()

    r_rdm1_rhf = res_rhf.get_r_rdm1()
    r_rdm1_uhf = res_uhf.get_r_rdm1()
    r_rdm1_fci = res_fci.get_r_rdm1()
    rdm1_tag   = r_rdm1_fci

    for res in [res_rhf, res_uhf, res_fci]:
        ene    = res.get_ene()
        r_rdm1 = res.get_r_rdm1()
        u_rdm1 = res.get_u_rdm1()

        dm_err = numpy.abs(r_rdm1_fci - r_rdm1) 
        err_max = numpy.max(dm_err)
        err_avg = numpy.linalg.norm(dm_err) / numpy.size(dm_err)

        print(f"\n\n{res.__class__.__name__}", file=log)
        print(f"Energy: {ene:6.4f}, Error Max: {err_max:6.4e}, Avg: {err_avg:6.4e}", file=log)
        print_matrix(r_rdm1,    t="r_rdm1 = ", stdout=log)
        print_matrix(u_rdm1[0], t="u_rdm1_alph = ", stdout=log)
        print_matrix(u_rdm1[1], t="u_rdm1_beta = ", stdout=log)

    for igen_loss, gen_loss in enumerate([gen_loss_function_r, gen_loss_function_u, gen_loss_function_g]):
        for (nimp, loss_func_type) in [(2, 1), (2, 2), (2, 3), (nsite, 1)]:
            if is_debug and (not (nimp == 2 and loss_func_type == 2)):
                continue
            
            f = gen_loss(
                hub_obj.h1, rdm1_tag, nelecs=nelecs, loss_func_type=loss_func_type, 
                fit_inds=numpy.asarray([[i+ifrag*nimp for i in range(nimp)] for ifrag in range(nsite // nimp)])
                )

            print("\n\n" + "#"*20, file=log)
            print(f"{gen_loss.__name__}", file=log)
            print(f"nimp = {nimp}, nsite = {nsite}", file=log)
            print(f"nelecs = {nelecs}", file=log)
            print(f"loss_func_type = {loss_func_type}", file=log)

            global count
            count = 0

            def callback(x, y, accepted):
                f1e_fit  = f._f1e + f._fill_correlation_potential(x)
                rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(f._get_density_matrix(f1e_fit))
                rdm1_err = jnumpy.abs(rdm1_tag - rdm1_fit)
                err_mean = jnumpy.linalg.norm(rdm1_err) / numpy.size(rdm1_err)
                err_max  = jnumpy.max(rdm1_err)

                global count
                if is_debug:
                    print(f"\nLoss Function = {y:6.4e}, {f.func(x):6.4e}, Error Mean: {err_mean:6.4e}, Max: {err_max:6.4e}, Count: {count}")
                    print(f"x = " + " ".join([f"{xi:6.4f}" for xi in x]))
                #     print_matrix(f1e_fit[0], t="f1e_fit  = ")
                #     print_matrix(f1e_fit[1], t="f1e_fit  = ")
                #     print_matrix(rdm1_fit,   t="rdm1_fit = ")
                #     print_matrix(rdm1_err,   t="rdm1_err = ")
                #     assert count != 10
                
                print(f"Loss Function = {y:6.4e}, Error Mean: {err_mean:6.4e}, Max: {err_max:6.4e}, Count: {count}", file=log)
                count += 1

            kwargs = {
                "method": "bfgs", 
                "jac": f.grad, 
                "tol": 1e-4, 
                "options": {"disp": False, "maxiter": 1000}
                }

            x0 = numpy.zeros(f._num_parm)

            res = basinhopping(
                f.func, x0, niter=1000, T=0.1, stepsize=0.6, disp=False,
                callback=callback, minimizer_kwargs=kwargs, 
                niter_success=100, interval=10, 
                )

            x = res.x
            f1e_fit  = f._f1e + f._fill_correlation_potential(x)
            rdm1_fit = (lambda rdm1: rdm1[0] + rdm1[1])(f._get_density_matrix(f1e_fit))
            rdm1_err = jnumpy.abs(rdm1_tag - rdm1_fit)
            err_mean = jnumpy.linalg.norm(rdm1_err) / numpy.size(rdm1_err)
            err_max  = jnumpy.max(rdm1_err)

            print(f"\nLoss Function = {y:6.4e}, Error Mean: {err_mean:6.4e}, Max: {err_max:6.4e}, Count: {count}", file=log)
            print(f"Success = {res.lowest_optimization_result.success}", file=log)
            print(f"Message = {res.lowest_optimization_result.message}", file=log)
            print(f"x = " + " ".join([f"{xi:6.4f}" for xi in x]), file=log)
            
            print(res, file=log)

            print_matrix(rdm1_fit,   t="rdm1_fit = ", stdout=log)
            print_matrix(rdm1_tag,   t="rdm1_tag = ", stdout=log)
            print("\n\n" + "#"*20, file=log)#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Junjies-MacBook-Air.local', release='22.5.0', version='Darwin Kernel Version 22.5.0: Thu Jun  8 22:21:34 PDT 2023; root:xnu-8796.121.3~7/RELEASE_ARM64_T8112', machine='arm64')  Threads 1
Python 3.11.3 | packaged by conda-forge | (main, Apr  6 2023, 08:58:31) [Clang 14.0.6 ]
numpy 1.24.3  scipy 1.10.1
Date: Thu Jul 20 22:44:47 2023
PySCF version 2.2.1
PySCF path  /Users/yangjunjie/packages/pyscf/pyscf-2.2.1/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 0
[INPUT] num. electrons = 6
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom

nuclear repulsion = 0
number of shells = 0
number of NR pGTOs = 0
number of NR cGTOs = 0
basis = sto-3g
ecp = {}
CPU time:         0.48


******** <class 'pyscf.scf.uhf.UHF'> ********
method = UHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-06
SCF conv_tol_grad = None
SCF max_cycles = 200
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/14/127wb84x5yx1jh4dxrvgcfkm0000gn/T/tmp0agb02z8
max_memory 4000 MB (current use 0 MB)
number electrons alpha = 3  beta = 3
Overwritten attributes  get_hcore get_ovlp  of <class 'pyscf.scf.uhf.UHF'>
Set gradient conv threshold to 0.001
init E= 0
  alpha nocc = 3  HOMO = -0.123105625617661  LUMO = 8.12310562561766
  beta  nocc = 3  HOMO = -0.123105625617661  LUMO = 8.12310562561766
cycle= 1 E= -1.47312115874708  delta_E= -1.47  |g|= 0.176  |ddm|= 0.575
  alpha nocc = 3  HOMO = 0.0903326183076389  LUMO = 7.90966738169236
  beta  nocc = 3  HOMO = 0.0903326183076365  LUMO = 7.90966738169237
cycle= 2 E= -1.47725639450065  delta_E= -0.00414  |g|= 0.0194  |ddm|= 0.0301
  alpha nocc = 3  HOMO = 0.115471455540606  LUMO = 7.88452854445939
  beta  nocc = 3  HOMO = 0.115471455540607  LUMO = 7.88452854445939
cycle= 3 E= -1.47730782420845  delta_E= -5.14e-05  |g|= 7.98e-05  |ddm|= 0.00375
  alpha nocc = 3  HOMO = 0.115575007304049  LUMO = 7.88442499269594
  beta  nocc = 3  HOMO = 0.11557500730405  LUMO = 7.88442499269595
cycle= 4 E= -1.47730782508382  delta_E= -8.75e-10  |g|= 3.74e-10  |ddm|= 1.55e-05
  alpha nocc = 3  HOMO = 0.115575006874255  LUMO = 7.88442499312574
  beta  nocc = 3  HOMO = 0.115575006874255  LUMO = 7.88442499312574
Extra cycle  E= -1.47730782508382  delta_E= -8.88e-16  |g|= 4.3e-11  |ddm|= 6.45e-11
converged SCF energy = -1.47730782508382  <S^2> = 2.6463192  2S+1 = 3.4037151


RestrictedHartreeFock
Energy: 4.0000, Error Max: 3.3953e-01, Avg: 3.7519e-02

r_rdm1 = 
        #0        #1        #2        #3        #4       
0       1.00000   0.66667  -0.00000  -0.33333   0.00000
1       0.66667   1.00000   0.66667  -0.00000  -0.33333
2      -0.00000   0.66667   1.00000   0.66667   0.00000
3      -0.33333  -0.00000   0.66667   1.00000   0.66667
4       0.00000  -0.33333   0.00000   0.66667   1.00000
5       0.66667   0.00000  -0.33333  -0.00000   0.66667
        #5       
0       0.66667
1       0.00000
2      -0.33333
3      -0.00000
4       0.66667
5       1.00000

u_rdm1_alph = 
        #0        #1        #2        #3        #4       
0       0.50000   0.33333  -0.00000  -0.16667   0.00000
1       0.33333   0.50000   0.33333  -0.00000  -0.16667
2      -0.00000   0.33333   0.50000   0.33333   0.00000
3      -0.16667  -0.00000   0.33333   0.50000   0.33333
4       0.00000  -0.16667   0.00000   0.33333   0.50000
5       0.33333   0.00000  -0.16667  -0.00000   0.33333
        #5       
0       0.33333
1       0.00000
2      -0.16667
3      -0.00000
4       0.33333
5       0.50000

u_rdm1_beta = 
        #0        #1        #2        #3        #4       
0       0.50000   0.33333  -0.00000  -0.16667   0.00000
1       0.33333   0.50000   0.33333  -0.00000  -0.16667
2      -0.00000   0.33333   0.50000   0.33333   0.00000
3      -0.16667  -0.00000   0.33333   0.50000   0.33333
4       0.00000  -0.16667   0.00000   0.33333   0.50000
5       0.33333   0.00000  -0.16667  -0.00000   0.33333
        #5       
0       0.33333
1       0.00000
2      -0.16667
3      -0.00000
4       0.33333
5       0.50000


UnrestrictedHartreeFock
Energy: -1.4773, Error Max: 8.4575e-02, Avg: 8.7529e-03

r_rdm1 = 
        #0        #1        #2        #3        #4       
0       1.00000   0.24256   0.00000  -0.01488   0.00000
1       0.24256   1.00000   0.24256  -0.00000  -0.01488
2       0.00000   0.24256   1.00000   0.24256   0.00000
3      -0.01488  -0.00000   0.24256   1.00000   0.24256
4       0.00000  -0.01488   0.00000   0.24256   1.00000
5       0.24256  -0.00000  -0.01488  -0.00000   0.24256
        #5       
0       0.24256
1      -0.00000
2      -0.01488
3      -0.00000
4       0.24256
5       1.00000

u_rdm1_alph = 
        #0        #1        #2        #3        #4       
0       0.96919   0.12128  -0.01396  -0.00744  -0.01396
1       0.12128   0.03081   0.12128   0.01396  -0.00744
2      -0.01396   0.12128   0.96919   0.12128  -0.01396
3      -0.00744   0.01396   0.12128   0.03081   0.12128
4      -0.01396  -0.00744  -0.01396   0.12128   0.96919
5       0.12128   0.01396  -0.00744   0.01396   0.12128
        #5       
0       0.12128
1       0.01396
2      -0.00744
3       0.01396
4       0.12128
5       0.03081

u_rdm1_beta = 
        #0        #1        #2        #3        #4       
0       0.03081   0.12128   0.01396  -0.00744   0.01396
1       0.12128   0.96919   0.12128  -0.01396  -0.00744
2       0.01396   0.12128   0.03081   0.12128   0.01396
3      -0.00744  -0.01396   0.12128   0.96919   0.12128
4       0.01396  -0.00744   0.01396   0.12128   0.03081
5       0.12128  -0.01396  -0.00744  -0.01396   0.12128
        #5       
0       0.12128
1      -0.01396
2      -0.00744
3      -0.01396
4       0.12128
5       0.96919


DirectSpin1FullConfigurationInteraction
Energy: -2.0481, Error Max: 0.0000e+00, Avg: 0.0000e+00

r_rdm1 = 
        #0        #1        #2        #3        #4       
0       1.00000   0.32714  -0.00000  -0.06223  -0.00000
1       0.32714   1.00000   0.32714   0.00000  -0.06223
2      -0.00000   0.32714   1.00000   0.32714  -0.00000
3      -0.06223   0.00000   0.32714   1.00000   0.32714
4      -0.00000  -0.06223  -0.00000   0.32714   1.00000
5       0.32714   0.00000  -0.06223   0.00000   0.32714
        #5       
0       0.32714
1       0.00000
2      -0.06223
3       0.00000
4       0.32714
5       1.00000

u_rdm1_alph = 
        #0        #1        #2        #3        #4       
0       0.50000   0.16357  -0.00000  -0.03112  -0.00000
1       0.16357   0.50000   0.16357   0.00000  -0.03112
2      -0.00000   0.16357   0.50000   0.16357  -0.00000
3      -0.03112   0.00000   0.16357   0.50000   0.16357
4      -0.00000  -0.03112  -0.00000   0.16357   0.50000
5       0.16357   0.00000  -0.03112   0.00000   0.16357
        #5       
0       0.16357
1       0.00000
2      -0.03112
3       0.00000
4       0.16357
5       0.50000

u_rdm1_beta = 
        #0        #1        #2        #3        #4       
0       0.50000   0.16357  -0.00000  -0.03112   0.00000
1       0.16357   0.50000   0.16357  -0.00000  -0.03112
2      -0.00000   0.16357   0.50000   0.16357   0.00000
3      -0.03112  -0.00000   0.16357   0.50000   0.16357
4       0.00000  -0.03112   0.00000   0.16357   0.50000
5       0.16357  -0.00000  -0.03112   0.00000   0.16357
        #5       
0       0.16357
1      -0.00000
2      -0.03112
3       0.00000
4       0.16357
5       0.50000


####################
gen_loss_function_r
nimp = 2, nsite = 6
nelecs = (3, 3)
loss_func_type = 2
Loss Function = 1.4405e+00, Error Mean: 3.7519e-02, Max: 3.3953e-01, Count: 0
Loss Function = 1.9945e+00, Error Mean: 3.9233e-02, Max: 4.1853e-01, Count: 1
Loss Function = 7.2754e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 2
Loss Function = 1.5706e+00, Error Mean: 5.1948e-02, Max: 6.6308e-01, Count: 3
Loss Function = 7.6475e-01, Error Mean: 4.6294e-02, Max: 6.5259e-01, Count: 4
Loss Function = 5.8929e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 5
Loss Function = 2.9883e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 6
Loss Function = 1.8484e+00, Error Mean: 4.5686e-02, Max: 4.8775e-01, Count: 7
Loss Function = 1.4944e+00, Error Mean: 3.9132e-02, Max: 3.7756e-01, Count: 8
Loss Function = 9.9204e-01, Error Mean: 4.6401e-02, Max: 6.3612e-01, Count: 9
Loss Function = 4.8562e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 10
Loss Function = 8.8423e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 11
Loss Function = 9.5378e-01, Error Mean: 3.9734e-02, Max: 4.8601e-01, Count: 12
Loss Function = 1.1142e-02, Error Mean: 4.1684e-02, Max: 5.8571e-01, Count: 13
Loss Function = 1.0912e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 14
Loss Function = 5.9412e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 15
Loss Function = 1.5214e+00, Error Mean: 3.7700e-02, Max: 3.4967e-01, Count: 16
Loss Function = 2.3977e-02, Error Mean: 4.1648e-02, Max: 5.8487e-01, Count: 17
Loss Function = 1.6646e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 18
Loss Function = 9.5593e-04, Error Mean: 4.1729e-02, Max: 5.8672e-01, Count: 19
Loss Function = 8.3818e-01, Error Mean: 4.6411e-02, Max: 6.4939e-01, Count: 20
Loss Function = 7.7206e-01, Error Mean: 4.6402e-02, Max: 6.5408e-01, Count: 21
Loss Function = 6.1256e-01, Error Mean: 4.0415e-02, Max: 5.3530e-01, Count: 22
Loss Function = 1.3943e-03, Error Mean: 4.1731e-02, Max: 5.8676e-01, Count: 23
Loss Function = 5.9061e-01, Error Mean: 4.1347e-02, Max: 5.5900e-01, Count: 24
Loss Function = 1.6801e+00, Error Mean: 5.2774e-02, Max: 6.5944e-01, Count: 25
Loss Function = 5.1347e-01, Error Mean: 4.4673e-02, Max: 6.3619e-01, Count: 26
Loss Function = 9.9037e-01, Error Mean: 4.3957e-02, Max: 5.8484e-01, Count: 27
Loss Function = 5.4702e-03, Error Mean: 4.1719e-02, Max: 5.8649e-01, Count: 28
Loss Function = 2.2079e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 29
Loss Function = 5.2525e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 30
Loss Function = 4.5506e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 31
Loss Function = 1.9267e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 32
Loss Function = 1.5305e+00, Error Mean: 3.8029e-02, Max: 3.3396e-01, Count: 33
Loss Function = 3.0777e-02, Error Mean: 4.1752e-02, Max: 5.8718e-01, Count: 34
Loss Function = 1.5335e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 35
Loss Function = 6.9770e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 36
Loss Function = 6.2221e-01, Error Mean: 3.9928e-02, Max: 5.2273e-01, Count: 37
Loss Function = 1.1335e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 38
Loss Function = 1.4106e-02, Error Mean: 4.1787e-02, Max: 5.8800e-01, Count: 39
Loss Function = 2.2579e+00, Error Mean: 5.2147e-02, Max: 5.5039e-01, Count: 40
Loss Function = 6.3363e-03, Error Mean: 4.1696e-02, Max: 5.8598e-01, Count: 41
Loss Function = 2.0309e-03, Error Mean: 4.1723e-02, Max: 5.8658e-01, Count: 42
Loss Function = 8.2003e-01, Error Mean: 4.6509e-02, Max: 6.5259e-01, Count: 43
Loss Function = 3.0949e-02, Error Mean: 4.1885e-02, Max: 5.9016e-01, Count: 44
Loss Function = 1.8246e+00, Error Mean: 5.2574e-02, Max: 6.3762e-01, Count: 45
Loss Function = 8.7181e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 46
Loss Function = 5.8115e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 47
Loss Function = 1.4614e-02, Error Mean: 4.1795e-02, Max: 5.8819e-01, Count: 48
Loss Function = 1.3418e+00, Error Mean: 4.4760e-02, Max: 5.5917e-01, Count: 49
Loss Function = 1.5505e+00, Error Mean: 4.9080e-02, Max: 6.2089e-01, Count: 50
Loss Function = 4.2739e-02, Error Mean: 4.1907e-02, Max: 5.9059e-01, Count: 51
Loss Function = 1.1910e+00, Error Mean: 4.0672e-02, Max: 4.7848e-01, Count: 52
Loss Function = 5.8685e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 53
Loss Function = 1.3183e-01, Error Mean: 4.1086e-02, Max: 5.7120e-01, Count: 54
Loss Function = 2.0715e+00, Error Mean: 4.6877e-02, Max: 4.8801e-01, Count: 55
Loss Function = 5.3604e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 56
Loss Function = 1.0930e-05, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 57
Loss Function = 2.0336e+00, Error Mean: 5.2465e-02, Max: 6.0212e-01, Count: 58
Loss Function = 8.5895e-01, Error Mean: 4.5774e-02, Max: 6.3548e-01, Count: 59
Loss Function = 2.0768e-03, Error Mean: 4.1717e-02, Max: 5.8644e-01, Count: 60
Loss Function = 1.5509e+00, Error Mean: 3.7612e-02, Max: 3.6227e-01, Count: 61
Loss Function = 1.0165e+00, Error Mean: 3.9841e-02, Max: 4.8100e-01, Count: 62
Loss Function = 2.5295e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 63
Loss Function = 2.2543e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 64
Loss Function = 7.6259e-01, Error Mean: 4.0651e-02, Max: 5.2904e-01, Count: 65
Loss Function = 3.9250e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 66
Loss Function = 6.6682e-02, Error Mean: 4.1386e-02, Max: 5.7874e-01, Count: 67
Loss Function = 1.8504e+00, Error Mean: 5.1635e-02, Max: 6.1975e-01, Count: 68
Loss Function = 2.0307e-01, Error Mean: 4.0732e-02, Max: 5.6172e-01, Count: 69
Loss Function = 1.5832e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 70
Loss Function = 2.3598e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 71
Loss Function = 1.7569e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 72
Loss Function = 2.6175e+00, Error Mean: 5.6712e-02, Max: 5.4926e-01, Count: 73
Loss Function = 1.1443e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 74
Loss Function = 2.4357e-02, Error Mean: 4.1851e-02, Max: 5.8942e-01, Count: 75
Loss Function = 9.6614e-01, Error Mean: 4.3847e-02, Max: 5.8489e-01, Count: 76
Loss Function = 7.5372e-03, Error Mean: 4.1699e-02, Max: 5.8604e-01, Count: 77
Loss Function = 1.2076e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 78
Loss Function = 2.4054e+00, Error Mean: 5.5406e-02, Max: 5.7603e-01, Count: 79
Loss Function = 3.3632e-02, Error Mean: 4.1632e-02, Max: 5.8447e-01, Count: 80
Loss Function = 6.4852e-02, Error Mean: 4.2023e-02, Max: 5.9305e-01, Count: 81
Loss Function = 2.5121e+00, Error Mean: 5.3809e-02, Max: 5.2339e-01, Count: 82
Loss Function = 1.6968e+00, Error Mean: 5.3165e-02, Max: 6.6152e-01, Count: 83
Loss Function = 8.1251e-01, Error Mean: 3.8449e-02, Max: 4.6838e-01, Count: 84
Loss Function = 1.0609e+00, Error Mean: 3.8114e-02, Max: 4.2830e-01, Count: 85
Loss Function = 1.0703e-03, Error Mean: 4.1729e-02, Max: 5.8672e-01, Count: 86
Loss Function = 1.5544e+00, Error Mean: 5.2496e-02, Max: 6.7117e-01, Count: 87
Loss Function = 1.7068e-01, Error Mean: 4.1552e-02, Max: 5.8119e-01, Count: 88
Loss Function = 1.7203e+00, Error Mean: 3.8510e-02, Max: 3.6053e-01, Count: 89
Loss Function = 4.0864e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 90
Loss Function = 2.6654e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 91
Loss Function = 1.8828e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 92
Loss Function = 1.1043e+00, Error Mean: 3.8228e-02, Max: 4.2496e-01, Count: 93
Loss Function = 7.7973e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 94
Loss Function = 2.6016e-02, Error Mean: 4.1763e-02, Max: 5.8744e-01, Count: 95
Loss Function = 7.7592e-01, Error Mean: 4.2895e-02, Max: 5.8095e-01, Count: 96
Loss Function = 1.0874e+00, Error Mean: 4.7027e-02, Max: 6.3889e-01, Count: 97
Loss Function = 5.4036e-02, Error Mean: 4.1510e-02, Max: 5.8165e-01, Count: 98
Loss Function = 1.8603e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 99
Loss Function = 2.4715e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 100
Loss Function = 1.5554e+00, Error Mean: 3.8828e-02, Max: 3.5338e-01, Count: 101
Loss Function = 1.1981e+00, Error Mean: 4.5717e-02, Max: 6.0006e-01, Count: 102
Loss Function = 2.7149e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 103
Loss Function = 1.0413e+00, Error Mean: 4.7155e-02, Max: 6.4580e-01, Count: 104
Loss Function = 3.3975e-04, Error Mean: 4.1726e-02, Max: 5.8665e-01, Count: 105
Loss Function = 1.9214e+00, Error Mean: 4.0098e-02, Max: 3.3384e-01, Count: 106
Loss Function = 1.3815e+00, Error Mean: 4.6200e-02, Max: 5.8630e-01, Count: 107
Loss Function = 2.2361e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 108
Loss Function = 4.3960e-01, Error Mean: 4.1932e-02, Max: 5.8099e-01, Count: 109
Loss Function = 1.8464e-03, Error Mean: 4.1720e-02, Max: 5.8651e-01, Count: 110
Loss Function = 8.0455e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 111
Loss Function = 1.0467e-03, Error Mean: 4.1725e-02, Max: 5.8663e-01, Count: 112
Loss Function = 8.9304e-01, Error Mean: 4.3002e-02, Max: 5.7291e-01, Count: 113
Loss Function = 2.2431e+00, Error Mean: 4.3033e-02, Max: 4.5068e-01, Count: 114
Loss Function = 9.1203e-02, Error Mean: 4.1265e-02, Max: 5.7578e-01, Count: 115
Loss Function = 5.0587e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 116
Loss Function = 1.0316e-02, Error Mean: 4.1709e-02, Max: 5.8626e-01, Count: 117
Loss Function = 2.0086e-03, Error Mean: 4.1721e-02, Max: 5.8654e-01, Count: 118
Loss Function = 1.1818e-03, Error Mean: 4.1719e-02, Max: 5.8649e-01, Count: 119
Loss Function = 1.4496e+00, Error Mean: 3.7778e-02, Max: 3.4560e-01, Count: 120
Loss Function = 3.3378e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 121
Loss Function = 4.7833e-02, Error Mean: 4.1559e-02, Max: 5.8279e-01, Count: 122
Loss Function = 3.1927e-02, Error Mean: 4.1884e-02, Max: 5.9013e-01, Count: 123
Loss Function = 1.2783e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 124
Loss Function = 2.7395e-01, Error Mean: 4.3114e-02, Max: 6.1317e-01, Count: 125
Loss Function = 1.7546e+00, Error Mean: 5.4319e-02, Max: 6.6461e-01, Count: 126
Loss Function = 7.7349e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 127
Loss Function = 1.3617e+00, Error Mean: 4.8346e-02, Max: 6.3262e-01, Count: 128
Loss Function = 4.2425e-01, Error Mean: 4.4133e-02, Max: 6.2927e-01, Count: 129
Loss Function = 3.0834e-04, Error Mean: 4.1724e-02, Max: 5.8661e-01, Count: 130
Loss Function = 1.7231e+00, Error Mean: 5.3811e-02, Max: 6.6434e-01, Count: 131
Loss Function = 2.4276e+00, Error Mean: 5.5663e-02, Max: 5.7511e-01, Count: 132
Loss Function = 1.1993e-01, Error Mean: 4.1397e-02, Max: 5.7846e-01, Count: 133
Loss Function = 6.6985e-02, Error Mean: 4.1395e-02, Max: 5.7894e-01, Count: 134
Loss Function = 4.5434e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 135
Loss Function = 1.7674e+00, Error Mean: 3.7830e-02, Max: 4.1653e-01, Count: 136
Loss Function = 7.1011e-03, Error Mean: 4.1698e-02, Max: 5.8602e-01, Count: 137
Loss Function = 7.5514e-01, Error Mean: 3.9012e-02, Max: 4.8863e-01, Count: 138
Loss Function = 1.0055e-03, Error Mean: 4.1721e-02, Max: 5.8655e-01, Count: 139
Loss Function = 3.6473e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 140
Loss Function = 2.0291e+00, Error Mean: 3.8607e-02, Max: 4.7823e-01, Count: 141
Loss Function = 1.1746e+00, Error Mean: 3.7770e-02, Max: 4.0059e-01, Count: 142
Loss Function = 1.8368e-02, Error Mean: 4.1819e-02, Max: 5.8872e-01, Count: 143
Loss Function = 1.4026e-01, Error Mean: 4.2473e-02, Max: 6.0216e-01, Count: 144
Loss Function = 9.0207e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 145
Loss Function = 6.9779e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 146
Loss Function = 1.2830e+00, Error Mean: 3.7702e-02, Max: 3.7889e-01, Count: 147
Loss Function = 7.8267e-01, Error Mean: 4.0397e-02, Max: 5.2096e-01, Count: 148
Loss Function = 2.1337e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 149
Loss Function = 9.1930e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 150
Loss Function = 5.2037e-01, Error Mean: 3.9394e-02, Max: 5.1647e-01, Count: 151
Loss Function = 1.4988e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 152
Loss Function = 1.0475e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 153
Loss Function = 3.3215e-02, Error Mean: 4.1851e-02, Max: 5.8939e-01, Count: 154
Loss Function = 2.0179e+00, Error Mean: 4.0079e-02, Max: 3.7312e-01, Count: 155
Loss Function = 1.4956e+00, Error Mean: 4.0302e-02, Max: 4.1269e-01, Count: 156
Loss Function = 1.8545e+00, Error Mean: 3.8039e-02, Max: 4.3644e-01, Count: 157
Loss Function = 1.1187e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 158
Loss Function = 2.0762e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 159
Loss Function = 1.4264e+00, Error Mean: 5.0123e-02, Max: 6.5497e-01, Count: 160
Loss Function = 2.5836e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 161
Loss Function = 3.6526e-05, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 162
Loss Function = 4.2695e-03, Error Mean: 4.1703e-02, Max: 5.8613e-01, Count: 163
Loss Function = 1.1464e-02, Error Mean: 4.1699e-02, Max: 5.8604e-01, Count: 164
Loss Function = 4.9418e-03, Error Mean: 4.1713e-02, Max: 5.8636e-01, Count: 165
Loss Function = 1.4110e-03, Error Mean: 4.1731e-02, Max: 5.8675e-01, Count: 166
Loss Function = 5.0643e-02, Error Mean: 4.1926e-02, Max: 5.9098e-01, Count: 167
Loss Function = 6.9575e-02, Error Mean: 4.1949e-02, Max: 5.9137e-01, Count: 168
Loss Function = 8.1583e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 169
Loss Function = 1.9842e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 170
Loss Function = 9.1037e-07, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 171
Loss Function = 5.6511e-01, Error Mean: 4.1289e-02, Max: 5.5929e-01, Count: 172
Loss Function = 2.8053e+00, Error Mean: 4.6425e-02, Max: 6.1116e-01, Count: 173
Loss Function = 3.9143e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 174
Loss Function = 1.6258e-02, Error Mean: 4.1646e-02, Max: 5.8484e-01, Count: 175
Loss Function = 1.1639e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 176
Loss Function = 2.7806e+00, Error Mean: 5.1164e-02, Max: 6.5471e-01, Count: 177
Loss Function = 2.1946e+00, Error Mean: 3.9602e-02, Max: 5.0148e-01, Count: 178
Loss Function = 1.7774e+00, Error Mean: 3.8461e-02, Max: 3.8207e-01, Count: 179
Loss Function = 2.7403e+00, Error Mean: 4.5519e-02, Max: 6.4582e-01, Count: 180
Loss Function = 3.5827e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 181
Loss Function = 2.1697e+00, Error Mean: 5.7228e-02, Max: 6.2955e-01, Count: 182
Loss Function = 2.5974e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 183
Loss Function = 2.1837e+00, Error Mean: 4.2492e-02, Max: 4.2787e-01, Count: 184
Loss Function = 2.1452e-02, Error Mean: 4.1615e-02, Max: 5.8414e-01, Count: 185
Loss Function = 1.1425e-01, Error Mean: 4.1224e-02, Max: 5.7460e-01, Count: 186
Loss Function = 1.5209e+00, Error Mean: 3.7565e-02, Max: 3.5694e-01, Count: 187
Loss Function = 2.0439e-01, Error Mean: 4.2063e-02, Max: 5.9198e-01, Count: 188
Loss Function = 1.6528e+00, Error Mean: 5.0543e-02, Max: 6.3197e-01, Count: 189
Loss Function = 1.8237e+00, Error Mean: 5.3497e-02, Max: 6.4887e-01, Count: 190
Loss Function = 5.2797e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 191
Loss Function = 4.9367e-02, Error Mean: 4.1773e-02, Max: 5.8757e-01, Count: 192
Loss Function = 5.7654e-01, Error Mean: 4.3425e-02, Max: 6.0676e-01, Count: 193
Loss Function = 1.0778e-01, Error Mean: 4.1690e-02, Max: 5.8522e-01, Count: 194
Loss Function = 4.7297e-03, Error Mean: 4.1706e-02, Max: 5.8619e-01, Count: 195
Loss Function = 1.7231e+00, Error Mean: 4.3993e-02, Max: 4.6943e-01, Count: 196
Loss Function = 3.3410e+00, Error Mean: 6.3027e-02, Max: 5.7641e-01, Count: 197
Loss Function = 2.2141e+00, Error Mean: 3.9868e-02, Max: 4.9307e-01, Count: 198
Loss Function = 1.5214e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 199
Loss Function = 3.5526e-04, Error Mean: 4.1723e-02, Max: 5.8658e-01, Count: 200
Loss Function = 3.8766e+00, Error Mean: 6.9814e-02, Max: 7.3532e-01, Count: 201
Loss Function = 2.6065e+00, Error Mean: 5.8906e-02, Max: 5.7359e-01, Count: 202
Loss Function = 3.1612e+00, Error Mean: 6.6888e-02, Max: 6.9281e-01, Count: 203
Loss Function = 2.5284e+00, Error Mean: 4.2165e-02, Max: 5.9471e-01, Count: 204
Loss Function = 8.8770e-04, Error Mean: 4.1727e-02, Max: 5.8669e-01, Count: 205
Loss Function = 2.1134e-02, Error Mean: 4.1793e-02, Max: 5.8812e-01, Count: 206
Loss Function = 3.0383e+00, Error Mean: 5.2700e-02, Max: 7.1613e-01, Count: 207
Loss Function = 5.9468e-02, Error Mean: 4.1859e-02, Max: 5.8943e-01, Count: 208
Loss Function = 2.3302e-01, Error Mean: 4.0668e-02, Max: 5.5949e-01, Count: 209
Loss Function = 2.4508e+00, Error Mean: 4.6270e-02, Max: 5.5732e-01, Count: 210
Loss Function = 1.1357e-01, Error Mean: 4.1491e-02, Max: 5.8068e-01, Count: 211
Loss Function = 2.6823e+00, Error Mean: 4.4254e-02, Max: 5.7115e-01, Count: 212
Loss Function = 1.8920e-01, Error Mean: 4.2711e-02, Max: 6.0650e-01, Count: 213
Loss Function = 1.4611e-01, Error Mean: 4.1544e-02, Max: 5.8142e-01, Count: 214
Loss Function = 1.8850e+00, Error Mean: 3.8545e-02, Max: 4.1669e-01, Count: 215
Loss Function = 2.2261e-01, Error Mean: 4.2871e-02, Max: 6.0924e-01, Count: 216
Loss Function = 1.1921e-01, Error Mean: 4.1988e-02, Max: 5.9175e-01, Count: 217
Loss Function = 1.9702e+00, Error Mean: 3.8484e-02, Max: 4.5754e-01, Count: 218
Loss Function = 3.3845e+00, Error Mean: 6.4959e-02, Max: 6.1517e-01, Count: 219
Loss Function = 1.3728e-02, Error Mean: 4.1796e-02, Max: 5.8821e-01, Count: 220
Loss Function = 2.9956e+00, Error Mean: 4.9323e-02, Max: 6.3962e-01, Count: 221
Loss Function = 2.7316e-06, Error Mean: 4.1725e-02, Max: 5.8662e-01, Count: 222
Loss Function = 2.5055e+00, Error Mean: 4.1904e-02, Max: 5.9039e-01, Count: 223
Loss Function = 1.9290e+00, Error Mean: 4.1869e-02, Max: 3.9226e-01, Count: 224
Loss Function = 7.2439e-03, Error Mean: 4.1688e-02, Max: 5.8579e-01, Count: 225
Loss Function = 2.3678e+00, Error Mean: 5.4150e-02, Max: 5.6407e-01, Count: 226
Loss Function = 2.5123e+00, Error Mean: 4.1979e-02, Max: 5.9192e-01, Count: 227
Loss Function = 7.8482e-02, Error Mean: 4.1689e-02, Max: 5.8550e-01, Count: 228
Loss Function = 2.2062e-02, Error Mean: 4.1830e-02, Max: 5.8895e-01, Count: 229
Loss Function = 2.0494e+00, Error Mean: 3.8727e-02, Max: 4.8037e-01, Count: 230
Loss Function = 3.3319e+00, Error Mean: 6.3339e-02, Max: 5.5703e-01, Count: 231
Loss Function = 1.1332e-01, Error Mean: 4.1977e-02, Max: 5.9158e-01, Count: 232
Loss Function = 2.4154e+00, Error Mean: 4.3482e-02, Max: 4.6019e-01, Count: 233
Loss Function = 2.0717e+00, Error Mean: 5.3563e-02, Max: 6.1225e-01, Count: 234
Loss Function = 2.8586e+00, Error Mean: 5.1116e-02, Max: 6.7100e-01, Count: 235
Loss Function = 1.9007e+00, Error Mean: 4.1379e-02, Max: 3.7192e-01, Count: 236
Loss Function = 1.5745e-05, Error Mean: 4.1724e-02, Max: 5.8662e-01, Count: 237
Loss Function = 1.0962e+00, Error Mean: 4.8167e-02, Max: 6.5862e-01, Count: 238
Loss Function = 1.6913e-02, Error Mean: 4.1640e-02, Max: 5.8471e-01, Count: 239
Loss Function = 7.4736e-01, Error Mean: 4.1335e-02, Max: 5.4695e-01, Count: 240
Loss Function = 2.3354e+00, Error Mean: 4.1527e-02, Max: 4.4033e-01, Count: 241
